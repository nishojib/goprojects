package problem

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// ContentTypeJSON https://tools.ietf.org/html/rfc9457#section-6.1
const ContentTypeJson = "application/problem+json"

// Problem is an RFC7807 error and can be compared with errors.Is().
type Problem struct {
	data   map[string]any
	reason error
}

// JSON returns the Problem as json bytes.
func (p Problem) JSON() []byte {
	b, _ := p.MarshalJSON()
	return b
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (p Problem) UnmarshalJSON(b []byte) error {
	return json.Unmarshal(b, &p.data)
}

// MarshalJSON implements the json.Marshaler interface.
func (p Problem) MarshalJSON() ([]byte, error) {
	return json.Marshal(&p.data)
}

// JSONString returns the Problem as json string.
func (p Problem) JSONString() string {
	return string(p.JSON())
}

// Error implements the error interface, so a Problem can be used as an error.
func (p Problem) Error() string {
	return p.JSONString()
}

// Is compares Problem.Error() with err.Error().
func (p Problem) Is(err error) bool {
	return p.Error() == err.Error()
}

// Unwrap returns the result of calling the Unwrap method on err, if err implements Unwrap.
// Otherwise, Unwrap returns nil.
func (p Problem) Unwrap() error {
	return p.reason
}

// WriteHeaderTo writes the HTTP headers for the JSON Problem ContentType and the
// problem's HTTP status code. THis is suitable for responding to HEAD requests.
func (p Problem) WriteHeaderTo(w http.ResponseWriter) {
	w.Header().Set("Content-Type", ContentTypeJson)
	if statusCode, ok := p.data["status"]; ok {
		if statusInt, ok := statusCode.(int); ok {
			w.WriteHeader(statusInt)
		}
	}
}

// WriteTo writes the JSON Problem to an HTTP Response Writer using the correct
// Content-Type and the problem's HTTP status code.
func (p Problem) WriteTo(w http.ResponseWriter) (int, error) {
	p.WriteHeaderTo(w)
	return w.Write(p.JSON())
}

// Append an Option to a existing Problem
func (p *Problem) Append(opts ...Option) *Problem {
	for _, opt := range opts {
		opt.apply(p)
	}
	return p
}

// An Option configures a Problem using the functional options paradigm
// popularized by Rob Pike
type Option interface {
	apply(*Problem)
}

type optionFunc func(*Problem)

func (f optionFunc) apply(problem *Problem) {
	f(problem)
}

// New generates a new Problem
func New(opts ...Option) *Problem {
	problem := &Problem{}
	problem.data = make(map[string]any)
	return problem.Append(opts...)
}

// Of creates a Problem based on status code with Title and Type automatically set
func Of(statusCode int) *Problem {
	return New(Status(statusCode), Title(http.StatusText(statusCode)), Type(getTypeUri(statusCode)))
}

// Wrap an error to the Problem
func Wrap(err error) Option {
	return optionFunc(func(p *Problem) {
		p.reason = err
		p.data["reason"] = err.Error()
	})
}

// WrapSilent wraps an error inside of the Problem without placing the wrapped
// error into the problem's JSON body. Useful for cases where the underlying
// error needs to be preserved but not transmitted to the user.
func WrapSilent(err error) Option {
	return optionFunc(func(p *Problem) {
		p.reason = err
	})
}

// Type sets the type URI (typically, with "http" or "https" scheme) that identifies the problem type.
// When dereferenced, it SHOULD provide human-readable documentation of the problem type.
func Type(uri string) Option {
	return optionFunc(func(p *Problem) {
		p.data["type"] = uri
	})
}

// Title sets a title that appropriately describes it (think short)
// Written in English and readable for engineers (usually not suited for
// non technical stakeholders and not localized).
// example - Service Unavailable
func Title(title string) Option {
	return optionFunc(func(p *Problem) {
		p.data["title"] = title
	})
}

// Titlef sets a title using a format string that appropriately describes it (think short)
// Written in English and readable for engineers (usually not suited for
// non technical stakeholders and not localized).
// example - Service Unavailable
func Titlef(format string, values ...any) Option {
	return Title(fmt.Sprintf(format, values...))
}

// Status sets the HTTP status code generated by the origin server for this
// occurrence of the problem.
func Status(status int) Option {
	return optionFunc(func(p *Problem) {
		p.data["status"] = status
	})
}

// Detail a human readable explanation specific to this occurrence of the problem.
func Detail(detail string) Option {
	return optionFunc(func(p *Problem) {
		p.data["detail"] = detail
	})
}

// Detailf a human readable explanation using a format string specific to this occurrence of the problem.
func Detailf(format string, values ...any) Option {
	return Detail(fmt.Sprintf(format, values...))
}

// Instance an absolute URI that identifies the specific occurrence of the problem.
func Instance(uri string) Option {
	return optionFunc(func(p *Problem) {
		p.data["instance"] = uri
	})
}

// Instancef an absolute URI using a format string that identifies the specific occurrence of the problem.
func Instancef(format string, values ...any) Option {
	return Instance(fmt.Sprintf(format, values...))
}

// Custom sets a custom key value
func Custom[T any](key string, value T) Option {
	return optionFunc(func(p *Problem) {
		p.data[key] = value
	})
}

func getTypeUri(statusCode int) string {
	codeSection := map[int]string{
		100: "6.2.1",
		101: "6.2.2",
		200: "6.3.1",
		201: "6.3.2",
		202: "6.3.3",
		203: "6.3.4",
		204: "6.3.5",
		205: "6.3.6",
		206: "4.1",
		300: "6.4.1",
		301: "6.4.2",
		302: "6.4.3",
		303: "6.4.4",
		304: "4.1",
		305: "6.4.5",
		307: "6.4.7",
		400: "6.5.1",
		401: "3.1",
		402: "6.5.2",
		403: "6.5.3",
		404: "6.5.4",
		405: "6.5.5",
		406: "6.5.6",
		407: "3.2",
		408: "6.5.7",
		409: "6.5.8",
		410: "6.5.9",
		411: "6.5.10",
		412: "4.2",
		413: "6.5.11",
		414: "6.5.12",
		415: "6.5.13",
		416: "4.4",
		417: "6.5.14",
		426: "6.5.15",
		500: "6.6.1",
		501: "6.6.2",
		502: "6.6.3",
		503: "6.6.4",
		504: "6.6.5",
		505: "6.6.6",
	}

	return fmt.Sprintf(
		"https://tools.ietf.org/html/rfc7231#section-%s",
		codeSection[statusCode],
	)
}
